# Отчет по лабораторной работе №1
## Работа со списками и реляционным представлением данных
## по курсу "Логическое программирование"

### студент: Бычков Д.А.

## Результат проверки

| Преподаватель     | Дата         |  Оценка       |
|-------------------|--------------|---------------|
| Сошников Д.В. |              |               |
| Левинская М.А.|              |               |

> *Комментарии проверяющих (обратите внимание, что более подробные комментарии возможны непосредственно в репозитории по тексту программы)*


## Введение

Лабораторная работа по работе со списками на Prolog предназначена для изучения основных операций и алгоритмов работы с данными в виде списков. Prolog - это язык программирования, основанный на логике, который широко используется для решения задач искусственного интеллекта, включая обработку и анализ данных.
В рамках этой лабораторной работы вы познакомитесь с основными операциями работы со списками на Prolog, такими как добавление элементов в список, удаление элементов из списка, поиск элементов в списке и другие. Вы также узнаете, как использовать рекурсию для обхода и обработки элементов списка.
В процессе выполнения лабораторной работы вы будете создавать и тестировать различные предикаты на Prolog, которые будут выполнять операции над списками. Вы также будете использовать предикаты для решения задач, связанных с обработкой данных в виде списков.
Эта лабораторная работа поможет вам развить навыки программирования на Prolog и понять основные принципы работы со списками. Вы также получите опыт в решении задач с использованием рекурсии и других алгоритмов работы со списками.
В конце лабораторной работы вы будете иметь полное представление о том, как работать со списками на Prolog и сможете применять эти знания в решении различных задач программирования.

## Задание 1.1: Предикат обработки списка

Усечение списка до указанной длины с использованием стандартный предикатов
```
truncated_list1(List,Res,N)
```
Усечение списка до указанной длины без стандартных предикатов
```
truncated_list2([X|Xs], N, [X|Ys])
```
Примеры использования:
```
?-truncated_list1([1, 2, 3, 4, 5], Res, 3).
Res = [1, 2, 3].

?-truncated_list2([1, 2, 3, 4, 5], Res, 3).
Res = [1, 2, 3].
```
Реализация:
```
truncated_list1(List,Res,N):-append(Res,_,List),length(Res,N),!.
```
Через append находит список который нам нужен, а length указывает его размеры
```
truncated_list2(_,[],0).
truncated_list2(_, 0, []).
truncated_list2([X|Xs], N, [X|Ys]) :-
    N > 0,
    N1 is N - 1,
    truncated_list2(Xs, N1, Ys),!.

 ``` 
truncated_list2(_,[],0) - предикат, который проверяет, что список пустой и N равно 0.
truncated_list2(_, 0, []) - предикат, который проверяет, что N равно 0 и результатом будет пустой список.
truncated_list2([X|Xs], N, [X|Ys]) - предикат, который рекурсивно вызывает сам себя для оставшихся элементов списка List и уменьшает значение N на 1.

## Задание 1.2: Предикат обработки числового списка.

Вычисление позиции минимального элемента в списке с использованием стандартных предикатов
```
min_position1(List, Position)
```
Версия без использования стандартных предикатовВерсия без использования стандартных предикатов
```
min_position2(List, Position) 
```
Примеры использования:
```
?-min_position1([5, 2, 7, 1, 3], Position).
Position = 4.

?-min_position2([5, 2, 7, 1, 3], Position).
Position=4.
```
Реализация:
```
min_position1(List, Position) :-
    min_list(List, Min),
    nth1(Position, List, Min).
```
Предикат min_position1(List, Position) использует функтор "min_list" для нахождения минимального элемента в списке List и функтор "nth1" для нахождения его позиции. Затем позиция присваивается переменной Position.
```
min_position2([X|Xs], Position) :-
    min_position2(Xs, X, 1, Position).

min_position2([], _, Position, Position).

min_position2([X|Xs], Min, CurrentPos, Position) :-
    X < Min,
    NewCurrentPos is CurrentPos + 1,
    min_position2(Xs, X, NewCurrentPos, Position).

min_position2([_|Xs], Min, CurrentPos, Position) :-
    NewCurrentPos is CurrentPos + 1,
    min_position2(Xs, Min, NewCurrentPos, Position).
   ``` 
Предикат min_position2(List, Position) также использует функторы "min_list" и "nth1" для нахождения минимального элемента и его позиции в списке List:
   - min_position2([], _, Position, Position) - предикат, который проверяет, что список пустой и присваивает текущую позицию переменной Position.
   - min_position2([X|Xs], Min, CurrentPos, Position) - предикат, который рекурсивно вызывает сам себя для оставшихся элементов списка List и обновляет значения переменных Min, CurrentPos и Position в зависимости от текущего элемента X.

Задание 1.3: Пример совместного использования.

 Предикат, который отсекает список до минимального элемента, с использованием стандартных предикатов
```
min_pos_comb1(List,Result)
```
Предикат, который отсекает список до минимального элемента, без использования стандартных предикатов
```
min_pos_comb2([X, Y | Tail], Result)
```
Примеры использования:
```
?-min_pos_comb1([5, 2, 7, 1, 3], Result).
Result = [5, 2, 7].
?-min_pos_comb2([5, 2, 7, 1, 3], Result).
Result = [5, 2, 7].
```
Реализация:
```
min_pos_comb1(List,Result):-
        min_position1(List,Position),truncated_list2(List,Position,Result).
```   
Предикат min_pos_comb1(List, Result) использует предикаты min_position1 и truncated_list2 для нахождения минимального элемента в списке List и всех элементов, которые находятся перед ним. Затем эти элементы добавляются в список Result. 
```
min_pos_comb2([], []).

min_pos_comb2([X], [X]).

min_pos_comb2([X, Y | Tail], Result) :-
    X =< Y, 
    min_pos_comb2([X | Tail], Result).

min_pos_comb2([X, Y | Tail], Result) :-
    X > Y, 
    min_pos_comb2([Y | Tail], Result).
```   
Предикат min_pos_comb2(List, Result) также использует предикаты min_position2 и truncated_list2 для нахождения минимального элемента в списке List и всех элементов, которые находятся перед ним. Затем эти элементы добавляются в список Result:
   - min_pos_comb2([], []) - предикат, который проверяет, что список пустой и результатом будет пустой список.
   - min_pos_comb2([X], [X]) - предикат, который проверяет, что список содержит только один элемент и результатом будет этот элемент.
   - min_pos_comb2([X, Y | Tail], Result) - предикат, который рекурсивно вызывает сам себя для оставшихся элементов списка List и обновляет список Result в зависимости от текущих элементов X и Y.
## Задание 2: Реляционное представление данных

Реляционное представление данных является одним из наиболее распространенных и эффективных способов организации информации в базе данных. Оно основано на использовании таблиц, где каждая строка представляет отдельную запись, а каждый столбец содержит определенный тип данных.

Одним из главных преимуществ реляционного представления данных является его структурированность. Таблицы обеспечивают удобный и понятный способ организации информации, что упрощает ее понимание и использование. Кроме того, реляционная модель обладает высокой гибкостью. Она позволяет легко добавлять, изменять и удалять данные, а также определять связи между различными таблицами.

Реляционная модель также обеспечивает целостность данных. Она поддерживает механизмы для обеспечения целостности, такие как ограничения целостности и транзакции. Это позволяет сохранять данные в согласованном состоянии и предотвращать их повреждение или потерю.

Кроме того, реляционная модель является универсальной и широко используемой. Она является стандартом в области баз данных, что облегчает совместимость и интеграцию с другими системами.

Задание 2.1: Для каждого студента, найти средний балл, и сдал ли он экзамены или нет.

Для каждого студента, найти средний балл
```
average_rating(Student,Mark)
```
Сдал ли студент экзамены
```
passed_ex(Student)
```

Примеры использования:
```
?- average_rating('Петров', Mark).
Mark = 3.8333333333333335.

?- passed_ex('Петров').
false.

?- passed_ex('Иванов').
true.

```
Реализация:

%2.1 Для каждого студента, найти средний балл, и сдал ли он экзамены или нет
%(Студент, Средняя оценка)
```
average_rating(Student,Mark):-
	student(_,Student,Grade),
	sum(Grade,Res),
	length(Grade,N),
	Mark is Res/N.
```
%Cумма всех элементов в списке
%(Список, Сумма)
```
sum([],0).
sum([grade(_,A)|B],Res):-
	sum(B,Res1),
	Res is Res1+A.


```
%Сдал ли студент экзамены
%Если хотя бы одна двойка, то false
%(Студент)
```
passed_ex(Student):-
    student(_,Student,Grade),
    not(member(grade(_,2),Grade)).
```
Предикат average_rating используется для вычисления среднего балла студента. Он принимает аргументы: фамилию студента и переменную для хранения среднего балла.
Предикат passed_ex/1 используется для определения, сдал ли студент все экзамены. Он принимает аргумент - фамилию студента и возвращает true, если студент сдал все экзамены, и false в противном случае.

Задание 2.2: Для каждого предмета, найти количество не сдавших студентов

Для каждого предмета, найти количество не сдавших студентов
```
subject_fail(Sub,Count)
```
Примеры использования:
```
?- subject_fail('FP', Count).
Count = 1.
```
Реализация:

%2.2 Для каждого предмета, найти количество не сдавших студентов
%(Предмет, количество)
```

grade_fail_exam([grade(Sub,2)|_],Sub).
grade_fail_exam([_|Grade],Sub):-
    grade_fail_exam(Grade,Sub).

subject_fail(Sub,Count):-
    subject(S,Sub),
    findall(Grade,(student(_,_,Grade),grade_fail_exam(Grade,S)),Total_fail),
    length(Total_fail,Count).
```
Предикат subject_fail/2 используется для определения количества студентов, не сдавших экзамен по определенному предмету. Он принимает аргументы: код предмета и переменную для хранения количества студентов.

Задание 2.3: Для каждой группы, найти студента (студентов) с максимальным средним баллом.

Для каждой группы, найти студента (студентов) с максимальным средним баллом
```
excellent_student(Group,List)
```
Примеры использования:
```
?- excellent_student(103,List).
List = ['Вебсервисов'].
```
Реализация:
```
max_elem([],0).
max_elem([H|T],N):-
  max_elem(T,B),
  H =< B,
  N is B.
max_elem([H|T],N):-
  max_elem(T,B),
  H >= B,
  N is H.
excellent_student(Group,List):-
    findall(Mark, (student(Group,Student,_), averageMark(Student,Mark)),Marks),
    max_elem(Marks,Max),
    findall(Name,(student(Group,Name,_), averageMark(Name,M), M==Max), List), !.

```
Предикат max_elem используется для нахождения максимального элемента в списке. Он принимает аргументы: список чисел и переменную для хранения максимального элемента.
Предикат excellent_student используется для нахождения студентов, имеющих максимальный средний балл в группе. Он принимает аргументы: код группы и переменную для хранения списка студентов с максимальным средним баллом.
## Выводы

Основной задачей данной лабораторной работы являлось изучение работы со списками в языке Пролог. Для этого были реализованы различные стандартные предикаты, такие как len(List, Length), member(X, List), append(List1, List2, Result), remove(X, List, Result), permute(List, PermutatedList). Также были реализованы предикаты для работы со списками, не использующие стандартные предикаты. 
Для выполнения заданий было необходимо использовать различные стандартные предикаты. Например, для нахождения длины списка использовался предикат len(List, Length), для проверки принадлежности элемента списку - member(X, List), для добавления списка в конец другого списка - append(List1, List2, Result). Использование стандартных предикатов позволило упростить реализацию заданий и сделать ее более читаемой.
Решая эту лабороторную работу я приобрел:
1) Навыки работы с языком Пролог, в частности, работа со списками и стандартными предикатами.
2) Навыки решения задач на Пролог, включая использование рекурсии и реляционного представления данных.
3) Умение анализировать и разбивать задачу на более мелкие подзадачи для более эффективного решения.
4) Навыки работы с отладчиком для поиска и исправления ошибок в программе.
5) Умение работать с отношениями между объектами и представлять данные в виде отношений.
6) Понимание принципов логического программирования и его отличий от императивного программирования.
